<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AWS Verified Permissions Quiz | AWS Security Specialty (SCS-C03)</title>
    <style>
        :root { --bg-primary: #0a0e17; --bg-secondary: #141b2d; --bg-tertiary: #1a2236; --text-primary: #e2e8f0; --text-secondary: #94a3b8; --accent-primary: #f59e0b; --accent-secondary: #fbbf24; --success: #22c55e; --error: #ef4444; --warning: #eab308; --info: #3b82f6; --border: #2d3a52; }
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { font-family: 'Segoe UI', system-ui, sans-serif; background: var(--bg-primary); color: var(--text-primary); line-height: 1.6; min-height: 100vh; }
        .container { max-width: 900px; margin: 0 auto; padding: 2rem; }
        header { text-align: center; margin-bottom: 2rem; padding: 2rem; background: linear-gradient(135deg, var(--bg-secondary) 0%, var(--bg-tertiary) 100%); border-radius: 16px; border: 1px solid var(--border); }
        .badge { display: inline-block; background: var(--accent-primary); color: white; padding: 0.25rem 0.75rem; border-radius: 20px; font-size: 0.75rem; font-weight: 600; margin-bottom: 1rem; text-transform: uppercase; }
        h1 { font-size: 2rem; margin-bottom: 0.5rem; background: linear-gradient(135deg, var(--accent-primary), var(--accent-secondary)); -webkit-background-clip: text; -webkit-text-fill-color: transparent; background-clip: text; }
        .subtitle { color: var(--text-secondary); font-size: 1rem; }
        .stats-bar { display: flex; justify-content: center; gap: 2rem; margin-top: 1.5rem; padding-top: 1.5rem; border-top: 1px solid var(--border); }
        .stat { text-align: center; } .stat-value { font-size: 1.5rem; font-weight: 700; color: var(--accent-primary); } .stat-label { font-size: 0.75rem; color: var(--text-secondary); text-transform: uppercase; }
        .mode-selector { display: flex; gap: 1rem; justify-content: center; margin-bottom: 2rem; }
        .mode-btn { padding: 0.75rem 2rem; border: 2px solid var(--border); background: var(--bg-secondary); color: var(--text-primary); border-radius: 8px; cursor: pointer; font-size: 1rem; transition: all 0.3s ease; }
        .mode-btn:hover { border-color: var(--accent-primary); background: var(--bg-tertiary); }
        .progress-container { background: var(--bg-secondary); border-radius: 12px; padding: 1rem 1.5rem; margin-bottom: 1.5rem; border: 1px solid var(--border); }
        .progress-header { display: flex; justify-content: space-between; align-items: center; margin-bottom: 0.75rem; }
        .progress-text { font-size: 0.875rem; color: var(--text-secondary); }
        .timer { font-size: 1.25rem; font-weight: 600; color: var(--accent-primary); font-family: 'Consolas', monospace; }
        .timer.warning { color: var(--warning); animation: pulse 1s infinite; } .timer.danger { color: var(--error); animation: pulse 0.5s infinite; }
        @keyframes pulse { 0%, 100% { opacity: 1; } 50% { opacity: 0.5; } }
        .progress-bar { height: 8px; background: var(--bg-tertiary); border-radius: 4px; overflow: hidden; }
        .progress-fill { height: 100%; background: linear-gradient(90deg, var(--accent-primary), var(--accent-secondary)); border-radius: 4px; transition: width 0.3s ease; }
        .question-card { background: var(--bg-secondary); border-radius: 16px; padding: 2rem; margin-bottom: 1.5rem; border: 1px solid var(--border); }
        .question-header { display: flex; justify-content: space-between; align-items: flex-start; margin-bottom: 1rem; }
        .question-number { background: var(--bg-tertiary); color: var(--accent-primary); padding: 0.25rem 0.75rem; border-radius: 6px; font-size: 0.875rem; font-weight: 600; }
        .question-domain { font-size: 0.75rem; color: var(--text-secondary); background: var(--bg-tertiary); padding: 0.25rem 0.5rem; border-radius: 4px; }
        .question-text { font-size: 1.125rem; margin-bottom: 1.5rem; line-height: 1.7; }
        .options { display: flex; flex-direction: column; gap: 0.75rem; }
        .option { display: flex; align-items: flex-start; gap: 1rem; padding: 1rem; background: var(--bg-tertiary); border: 2px solid var(--border); border-radius: 10px; cursor: pointer; transition: all 0.2s ease; }
        .option:hover:not(.disabled) { border-color: var(--accent-primary); background: rgba(245, 158, 11, 0.1); }
        .option.selected { border-color: var(--accent-primary); border-width: 3px; background: rgba(245, 158, 11, 0.2); box-shadow: 0 0 0 3px rgba(245, 158, 11, 0.25), inset 0 0 12px rgba(245, 158, 11, 0.1); }
        .option.correct { border-color: var(--success); background: rgba(34, 197, 94, 0.15); }
        .option.incorrect { border-color: var(--error); background: rgba(239, 68, 68, 0.15); }
        .option.disabled { cursor: default; }
        .option-marker { width: 28px; height: 28px; border-radius: 50%; border: 2px solid var(--border); display: flex; align-items: center; justify-content: center; font-weight: 600; font-size: 0.875rem; flex-shrink: 0; }
        .option.selected .option-marker { border-color: var(--accent-primary); background: var(--accent-primary); color: white; }
        .option.correct .option-marker { border-color: var(--success); background: var(--success); color: white; }
        .option.incorrect .option-marker { border-color: var(--error); background: var(--error); color: white; }
        .option-text { flex: 1; padding-top: 2px; }
        .explanation { margin-top: 1.5rem; padding: 1.5rem; background: var(--bg-tertiary); border-radius: 10px; border-left: 4px solid var(--info); display: none; }
        .explanation.show { display: block; animation: fadeIn 0.3s ease; }
        @keyframes fadeIn { from { opacity: 0; transform: translateY(-10px); } to { opacity: 1; transform: translateY(0); } }
        .explanation-title { display: flex; align-items: center; gap: 0.5rem; font-weight: 600; margin-bottom: 0.75rem; color: var(--info); }
        .answer-header { font-weight: 600; color: var(--success); margin-bottom: 0.5rem; }
        .explanation-text { color: var(--text-secondary); margin-bottom: 1rem; }
        .doc-link { display: inline-flex; align-items: center; gap: 0.5rem; color: var(--accent-primary); text-decoration: none; font-size: 0.875rem; padding: 0.5rem 1rem; background: rgba(245, 158, 11, 0.1); border-radius: 6px; }
        .doc-link:hover { background: rgba(245, 158, 11, 0.2); }
        .btn-container { display: flex; justify-content: space-between; gap: 1rem; margin-top: 1rem; }
        .btn { padding: 0.75rem 1.5rem; border: none; border-radius: 8px; font-size: 1rem; font-weight: 600; cursor: pointer; transition: all 0.2s ease; }
        .btn-primary { background: linear-gradient(135deg, var(--accent-primary), var(--accent-secondary)); color: white; }
        .btn-primary:hover { transform: translateY(-2px); box-shadow: 0 4px 12px rgba(245, 158, 11, 0.4); }
        .btn-secondary { background: var(--bg-tertiary); color: var(--text-primary); border: 1px solid var(--border); }
        .btn-secondary:hover { border-color: var(--accent-primary); }
        .btn:disabled { opacity: 0.5; cursor: not-allowed; }
        .results-card { background: var(--bg-secondary); border-radius: 16px; padding: 2rem; text-align: center; border: 1px solid var(--border); display: none; }
        .results-card.show { display: block; animation: fadeIn 0.5s ease; }
        .results-score { font-size: 4rem; font-weight: 700; margin: 1rem 0; }
        .results-score.pass { color: var(--success); } .results-score.fail { color: var(--error); }
        .results-status { font-size: 1.5rem; margin-bottom: 1rem; }
        .results-status.pass { color: var(--success); } .results-status.fail { color: var(--error); }
        .results-details { color: var(--text-secondary); margin-bottom: 2rem; }
        .results-breakdown { display: flex; justify-content: center; gap: 3rem; margin-bottom: 2rem; padding: 1.5rem; background: var(--bg-tertiary); border-radius: 10px; }
        .breakdown-item { text-align: center; } .breakdown-value { font-size: 2rem; font-weight: 700; } .breakdown-value.correct { color: var(--success); } .breakdown-value.incorrect { color: var(--error); } .breakdown-label { font-size: 0.875rem; color: var(--text-secondary); }
        .review-section { background: var(--bg-secondary); border-radius: 16px; padding: 2rem; border: 1px solid var(--border); display: none; }
        .review-section.show { display: block; animation: fadeIn 0.5s ease; }
        .review-header { text-align: center; margin-bottom: 2rem; }
        .review-table { width: 100%; border-collapse: collapse; margin-bottom: 2rem; }
        .review-table th { background: var(--bg-tertiary); color: var(--text-secondary); font-size: 0.875rem; font-weight: 600; text-transform: uppercase; padding: 1rem; text-align: left; border-bottom: 2px solid var(--border); }
        .review-table td { padding: 1rem; border-bottom: 1px solid var(--border); vertical-align: top; }
        .review-table tbody tr { cursor: pointer; transition: all 0.2s ease; }
        .review-table tbody tr:hover { background: rgba(245, 158, 11, 0.1); transform: translateX(4px); }
        .review-table tbody tr.reviewed { background: rgba(245, 158, 11, 0.25); border-left: 6px solid var(--accent-primary); box-shadow: inset 0 0 20px rgba(245, 158, 11, 0.15); }
        .review-table tbody tr.reviewed:hover { background: rgba(245, 158, 11, 0.3); }
        .review-table tbody tr.reviewed .review-q-num { color: var(--accent-secondary); font-weight: 800; }
        .review-table tbody tr.reviewed .review-q-num::before { content: "‚úì "; color: var(--accent-primary); font-size: 1rem; }
        .review-q-num { font-weight: 700; color: var(--accent-primary); white-space: nowrap; }
        .review-q-text { color: var(--text-primary); line-height: 1.6; }
        .review-answer { font-weight: 600; }
        .review-answer.correct { color: var(--success); }
        .review-answer.incorrect { color: var(--error); }
        .review-status { text-align: center; font-size: 1.25rem; }
        .review-hint { text-align: center; color: var(--text-secondary); font-size: 0.875rem; margin-bottom: 1rem; }
        .btn-group { display: flex; gap: 1rem; justify-content: center; }
        .hidden { display: none !important; }
        .shuffle-notice { text-align: center; padding: 0.75rem; background: rgba(245, 158, 11, 0.1); border-radius: 8px; margin-bottom: 1.5rem; color: var(--accent-secondary); font-size: 0.875rem; }
        @media (max-width: 640px) { .container { padding: 1rem; } h1 { font-size: 1.5rem; } .stats-bar { gap: 1rem; } .mode-selector, .btn-container, .results-breakdown { flex-direction: column; } }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <span class="badge">Domain 4: Identity & Access Management (22%)</span>
            <h1>üîê AWS Verified Permissions (Cedar)</h1>
            <p class="subtitle">Comprehensive Quiz for AWS Security Specialty (SCS-C03)</p>
            <div class="stats-bar">
                <div class="stat"><div class="stat-value">25</div><div class="stat-label">Questions</div></div>
                <div class="stat"><div class="stat-value">80%</div><div class="stat-label">Pass Score</div></div>
                <div class="stat"><div class="stat-value">62:30</div><div class="stat-label">Exam Time</div></div>
            </div>
        </header>
        <div class="mode-selector" id="modeSelector">
            <button class="mode-btn" onclick="startQuiz('learn')">üìö Learn Mode</button>
            <button class="mode-btn" onclick="startQuiz('exam')">‚è±Ô∏è Exam Mode</button>
        </div>
        <div id="quizContent" class="hidden">
            <div class="progress-container">
                <div class="progress-header">
                    <span class="progress-text">Question <span id="currentQ">1</span> of <span id="totalQ">25</span></span>
                    <span class="timer" id="timer">62:30</span>
                </div>
                <div class="progress-bar"><div class="progress-fill" id="progressFill" style="width: 0%"></div></div>
            </div>
            <div class="shuffle-notice" id="shuffleNotice">üîÄ Questions and options have been randomized</div>
            <div id="questionsContainer"></div>
            <div class="btn-container">
                <button class="btn btn-secondary" id="prevBtn" onclick="navigate(-1)" disabled>‚Üê Previous</button>
                <button class="btn btn-secondary" id="backToReviewBtn" onclick="backToReview()" style="display: none;">‚Üê Back to Review</button>
                <button class="btn btn-secondary" id="shuffleBtn" onclick="shuffleQuiz()">üîÄ Shuffle</button>
                <button class="btn btn-primary" id="nextBtn" onclick="navigate(1)">Next ‚Üí</button>
            </div>
        </div>
        <div class="results-card" id="resultsCard">
            <h2>Quiz Complete!</h2>
            <div class="results-score" id="scorePercent">0%</div>
            <div class="results-status" id="resultStatus">-</div>
            <p class="results-details" id="resultDetails"></p>
            <div class="results-breakdown">
                <div class="breakdown-item"><div class="breakdown-value correct" id="correctCount">0</div><div class="breakdown-label">Correct</div></div>
                <div class="breakdown-item"><div class="breakdown-value incorrect" id="incorrectCount">0</div><div class="breakdown-label">Incorrect</div></div>
            </div>
            <div class="btn-group">
                <button class="btn btn-primary" onclick="showReview()">üìä Review Answers</button>
                <button class="btn btn-secondary" onclick="restartQuiz()">üîÑ Restart Quiz</button>
            </div>
        </div>
        <div class="review-section" id="reviewSection">
            <div class="review-header">
                <h2>Answer Review</h2>
                <p class="results-details">Click any question to review the full answer and explanation</p>
            </div>
            <p class="review-hint">üí° Tip: Click on any row to see the full question and explanation in Learn mode</p>
            <table class="review-table">
                <thead>
                    <tr>
                        <th style="width: 5%">#</th>
                        <th style="width: 50%">Question</th>
                        <th style="width: 15%">Your Answer</th>
                        <th style="width: 15%">Correct Answer</th>
                        <th style="width: 10%">Status</th>
                    </tr>
                </thead>
                <tbody id="reviewTableBody"></tbody>
            </table>
            <div class="btn-group">
                <button class="btn btn-secondary" onclick="backToResults()">‚Üê Back to Results</button>
                <button class="btn btn-primary" onclick="restartQuiz()">üîÑ Restart Quiz</button>
            </div>
        </div>
    </div>
    <script>
        const questions = [
            { id: 1, question: "What is the primary purpose of Amazon Verified Permissions in application security architecture?", options: ["To provide authentication services for verifying user identities through multi-factor authentication and biometric validation", "To externalize and centralize fine-grained authorization and policy management for custom applications using the Cedar policy language", "To encrypt application data at rest and in transit using AWS KMS and TLS certificates for secure communications", "To monitor application traffic patterns and detect anomalous behavior using machine learning models and threat intelligence"], correct: 1, explanation: "Amazon Verified Permissions is a scalable, fine-grained permissions management and authorization service that enables developers to externalize authorization from application code and centralize policy management. It uses the Cedar policy language to define permissions and handles authorization decisions, but assumes authentication has been done separately (it's authentication-agnostic). This separation of concerns accelerates secure application development.", docLink: "https://docs.aws.amazon.com/verifiedpermissions/latest/userguide/what-is-avp.html" },
            { id: 2, question: "What is Cedar and how does it relate to Amazon Verified Permissions?", options: ["Cedar is a proprietary AWS encryption protocol used exclusively for securing Verified Permissions API calls and policy storage", "Cedar is an open source policy language for writing authorization policies; Verified Permissions uses Cedar to evaluate policies and provide access decisions", "Cedar is an AWS service for certificate management that integrates with Verified Permissions for mTLS authentication and identity verification", "Cedar is a database engine optimized for storing authorization logs and audit trails generated by Verified Permissions policy evaluations"], correct: 1, explanation: "Cedar is an open source policy language for writing authorization policies and making authorization decisions. When applications make requests to Verified Permissions, Cedar policies are evaluated to determine if an action is allowed or denied. Cedar enables decoupling business logic from authorization logic. Verified Permissions currently uses Cedar version 4.7 and provides APIs to manage Cedar policies.", docLink: "https://docs.aws.amazon.com/verifiedpermissions/latest/userguide/what-is-avp.html" },
            { id: 3, question: "What are the two required effect types in a Cedar policy, and how are they evaluated?", options: ["The effects are 'allow' and 'deny', evaluated using an explicit deny overrides model where any deny statement blocks access", "The effects are 'permit' and 'forbid', evaluated using a forbid-overrides-permit model where any forbid results in deny, otherwise permit policies must match", "The effects are 'grant' and 'revoke', evaluated using a most-specific-wins model based on resource hierarchy and policy precedence", "The effects are 'accept' and 'reject', evaluated using a first-match-wins model based on policy creation timestamp and ordering"], correct: 1, explanation: "Cedar policies use 'permit' or 'forbid' as effects (not 'allow'/'deny'). Cedar uses a forbid-overrides-permit evaluation model: if any forbid policy matches, the result is Deny; else if any permit policy matches, the result is Allow; otherwise default is Deny. This means you need at least one matching permit and zero matching forbid policies for authorization to succeed.", docLink: "https://docs.cedarpolicy.com/auth/authorization.html" },
            { id: 4, question: "What is a policy store in Amazon Verified Permissions and what is the recommended approach for multi-tenant applications?", options: ["A policy store is a temporary cache for frequently accessed policies; multi-tenant applications should share one global policy store for performance", "A policy store is a container for policies and templates with a schema for validation; create one policy store per application or one per tenant for multi-tenant apps", "A policy store is a backup location for disaster recovery; multi-tenant applications should replicate policy stores across multiple regions automatically", "A policy store is an audit log repository for tracking authorization decisions; multi-tenant applications should use separate S3 buckets per tenant"], correct: 1, explanation: "A policy store is a container for Cedar policies and policy templates. Each policy store contains a schema that validates policies added to the store. AWS recommends creating one policy store per application, or for multi-tenant applications, one policy store per tenant. When applications make authorization requests, they specify which policy store to evaluate. This isolation enables using namespaces to keep tenant policies separate and identifiable.", docLink: "https://docs.aws.amazon.com/verifiedpermissions/latest/userguide/policy-stores.html" },
            { id: 5, question: "What is the purpose of a schema in an Amazon Verified Permissions policy store?", options: ["A schema defines the database structure for storing authorization logs and audit trails in DynamoDB tables with predefined columns", "A schema declares entity types, validates entities and attributes, and ensures policies conform to defined principal, resource, and action structures", "A schema specifies the encryption algorithms and key rotation schedules for protecting policy data at rest in S3 buckets", "A schema configures the API rate limits and throttling behavior for authorization requests to prevent denial of service attacks"], correct: 1, explanation: "A policy store schema declares the entity types (principals, resources, actions) and their attributes that can be referenced in policies. It validates that policies conform to the defined structure, ensuring policies only reference valid entity types and attributes. When policy validation is enabled, invalid policies are rejected. This type safety helps prevent errors and makes policies more maintainable. Schemas can be created in JSON or Visual mode.", docLink: "https://docs.aws.amazon.com/verifiedpermissions/latest/userguide/schema.html" },
            { id: 6, question: "What are the mandatory elements in a Cedar policy's scope definition?", options: ["The scope must define only the principal and action, while resource specification is optional for global policy application", "The scope must define the principal (who is making the request), action (what they want to do), and resource (what they want to access)", "The scope must define only the resource and action, while principal can be wildcarded for public resource policies", "The scope must define the action and conditions, while principal and resource are inherited from parent policy templates"], correct: 1, explanation: "Every Cedar policy scope must include three mandatory elements: principal (who is making the request), action (what operation they want to perform), and resource (what they want to access). These elements define the request parameters that the policy applies to. The scope helps improve performance by narrowing the set of considered policies during evaluation - only policies relevant to the request are considered.", docLink: "https://docs.aws.amazon.com/verifiedpermissions/latest/userguide/terminology.html" },
            { id: 7, question: "What are 'when' and 'unless' clauses in Cedar policies, and how do they affect policy evaluation?", options: ["'when' and 'unless' are policy metadata annotations that document policy intent but have no impact on authorization evaluation logic", "'when' and 'unless' are optional condition clauses that must evaluate to true (for when) or false (for unless) for the policy to take effect", "'when' and 'unless' define time-based access windows specifying hours of the day when authorization is granted or explicitly denied", "'when' and 'unless' specify API throttling thresholds that limit the number of authorization requests per principal per time period"], correct: 1, explanation: "When and unless are optional condition clauses that add fine-grained logic to Cedar policies. A policy evaluates to true only when: (1) the request matches the scope (principal, action, resource), (2) all 'when' clauses evaluate to true, and (3) all 'unless' clauses evaluate to false. Conditions can reference attributes of principals, resources, and context data to implement attribute-based access control (ABAC) alongside role-based patterns.", docLink: "https://docs.cedarpolicy.com/policies/syntax-policy.html" },
            { id: 8, question: "What is an identity source in Amazon Verified Permissions and which AWS services can serve as identity sources?", options: ["An identity source is an S3 bucket containing user credential files; only S3 and DynamoDB can serve as identity sources", "An identity source integrates authenticated identities into policy evaluation; Amazon Cognito user pools and OIDC providers can serve as identity sources", "An identity source is an IAM role that Verified Permissions assumes; only IAM roles and IAM Identity Center can serve as identity sources", "An identity source is a CloudTrail log that tracks authentication events; only CloudTrail and CloudWatch Logs can serve as identity sources"], correct: 1, explanation: "An identity source integrates authenticated identities (principals) from external identity providers into Verified Permissions policy evaluation. Supported identity sources include Amazon Cognito user pools and OIDC-compatible providers. The identity source maps identity provider users and groups to Cedar principal entity types, enabling policies to reference token attributes (claims). Verified Permissions is authentication-agnostic - it assumes authentication happened elsewhere and focuses on authorization.", docLink: "https://docs.aws.amazon.com/verifiedpermissions/latest/userguide/cognito-create.html" },
            { id: 9, question: "When creating an Amazon Cognito identity source in Verified Permissions, what does the 'principal entity type' configuration specify?", options: ["It specifies the IAM role that Cognito users will assume when accessing AWS services through the application", "It specifies which entity type in the policy store schema that identities from the Cognito user pool will be mapped to (e.g., 'User' type)", "It specifies the encryption type for principal identifiers when stored in CloudTrail logs for compliance and auditing purposes", "It specifies the maximum number of concurrent principals that can authenticate simultaneously from the connected user pool"], correct: 1, explanation: "The principal entity type configuration maps Cognito user pool identities to a specific entity type defined in your policy store schema. For example, users from the Cognito user pool might map to a 'User' entity type in your schema. This enables Cedar policies to reference these principals with proper type validation. You can also configure group mapping, where Cognito user groups (cognito:groups claim) map to a parent entity type for role-based access control.", docLink: "https://docs.aws.amazon.com/verifiedpermissions/latest/userguide/cognito-create.html" },
            { id: 10, question: "What is the significance of UUIDs in Cedar policy identifiers according to AWS best practices?", options: ["UUIDs improve query performance by creating indexed lookups in the policy evaluation engine for faster authorization decisions", "UUIDs prevent identifier reuse - if a user leaves and their username is reassigned, old policies won't unintentionally grant access to the new user", "UUIDs enable automatic policy replication across regions by providing globally unique references for disaster recovery purposes", "UUIDs are required by Cedar syntax validation and policies will fail to parse without properly formatted UUID identifiers"], correct: 1, explanation: "AWS strongly recommends using UUIDs for all principal and resource identifiers to prevent identifier reuse issues. If you use a username like 'jane' and that person leaves the company, later assigning the same name to a new employee would automatically grant them all permissions from old policies referencing 'jane'. UUIDs ensure unique, never-reused identifiers. AWS recommends following UUIDs with // comments containing friendly names for readability (e.g., User::\"uuid\" // jane).", docLink: "https://docs.aws.amazon.com/verifiedpermissions/latest/userguide/policies.html" },
            { id: 11, question: "What should you avoid including in Cedar policy identifiers for principals and resources according to security best practices?", options: ["You should avoid using descriptive names or labels as they make policies harder to understand and maintain over time", "You should avoid including personally identifying information (PII), confidential data, or sensitive information as identifiers are included in CloudTrail logs", "You should avoid using numeric identifiers as they conflict with Cedar's internal numbering system for policy evaluation ordering", "You should avoid using entity type prefixes like 'User::' or 'Role::' as they cause namespace collision issues"], correct: 1, explanation: "Do not include PII, confidential information, or sensitive data as part of unique identifiers for principals or resources. These identifiers are included in log entries shared in AWS CloudTrail trails, which could expose sensitive information. For example, don't use Social Security numbers or employee IDs as identifiers. Use UUIDs instead, with friendly names in comments if needed for readability without security risk.", docLink: "https://docs.aws.amazon.com/verifiedpermissions/latest/userguide/policies.html" },
            { id: 12, question: "What are the components of an authorization request in Amazon Verified Permissions?", options: ["An authorization request contains only the policy store ID and access token for the authenticated user making the request", "An authorization request includes the principal (who), action (what operation), resource (what entity), optional context data, and the policy store to evaluate", "An authorization request contains the Cedar policy text to evaluate, the schema definition, and the encryption keys for secure transmission", "An authorization request includes only the API endpoint URL, HTTP method, and request body payload for the operation being authorized"], correct: 1, explanation: "An authorization request made by an application to Verified Permissions includes: principal (the entity making the request), action (the operation being performed), resource (the entity being accessed), optional context data (additional attributes for evaluation), and specification of which policy store to evaluate. Verified Permissions evaluates relevant Cedar policies and returns an allow or deny decision plus information about determining policies.", docLink: "https://docs.aws.amazon.com/verifiedpermissions/latest/userguide/terminology.html" },
            { id: 13, question: "What does the authorization response from Amazon Verified Permissions include?", options: ["The response includes only a boolean true/false value indicating whether the action is permitted without additional metadata", "The response includes an allow or deny decision, the IDs of determining policies, and optionally error information if evaluation failed", "The response includes the complete execution trace of all policies evaluated, including performance metrics and optimization suggestions", "The response includes the updated Cedar policy set with dynamic modifications based on context data and real-time threat intelligence"], correct: 1, explanation: "The authorization response includes: (1) an allow or deny decision for the requested action, (2) the IDs of determining policies (the policies that led to the decision), and (3) additional metadata. This information helps with debugging authorization issues, auditing decisions, and understanding why access was granted or denied. The determining policies are particularly useful for explaining authorization outcomes to end users or security teams.", docLink: "https://docs.aws.amazon.com/verifiedpermissions/latest/userguide/terminology.html" },
            { id: 14, question: "What is the difference between 'considered policies' and 'determining policies' in Verified Permissions evaluation?", options: ["Considered policies are those written by administrators, while determining policies are those auto-generated by machine learning algorithms", "Considered policies are the full set selected for evaluation based on relevance; determining policies are those that actually determine the final decision", "Considered policies are stored in the primary region, while determining policies are replicated across availability zones for high availability", "Considered policies are validated against the schema, while determining policies are those that failed validation and require manual review"], correct: 1, explanation: "Considered policies are the full set of policies selected by Verified Permissions for evaluation based on relevance to the authorization request (matching principal, action, resource scope). Determining policies are the subset of satisfied policies that actually determine the authorization response. For example, if multiple permit policies match but one forbid policy also matches, the forbid policy is the determining policy. If no policies match, there are no determining policies and the default deny applies.", docLink: "https://docs.aws.amazon.com/verifiedpermissions/latest/userguide/terminology.html" },
            { id: 15, question: "How does Amazon Verified Permissions support both Role-Based Access Control (RBAC) and Attribute-Based Access Control (ABAC)?", options: ["RBAC is implemented through IAM policies while ABAC requires separate AWS Attribute Manager service integration for attribute evaluation", "RBAC is supported through principal groups in Cedar, while ABAC uses policy conditions referencing attributes; both can be combined in a single policy", "RBAC requires Cognito user pools while ABAC requires OIDC providers - they cannot be used together in the same policy store", "RBAC is available in all regions while ABAC is only available in US regions due to compliance requirements for attribute processing"], correct: 1, explanation: "Cedar supports both RBAC and ABAC patterns. RBAC is implemented through principal groups (roles) where policies are defined for groups of users. ABAC is implemented through policy conditions (when/unless clauses) that reference attributes of the principal, resource, or context. Cedar enables combining both patterns in a single policy - you can define permissions for a group of users with attribute-based conditions, providing flexible authorization models.", docLink: "https://docs.aws.amazon.com/verifiedpermissions/latest/userguide/terminology.html" },
            { id: 16, question: "What happens when policy validation is enabled in a Verified Permissions policy store?", options: ["Policy validation automatically fixes syntax errors in Cedar policies by applying machine learning-based correction algorithms", "Policy validation checks that entity types, common types, and actions in policies match the schema, rejecting invalid policies that don't conform", "Policy validation encrypts all policies using AWS KMS customer-managed keys to ensure confidentiality of authorization rules", "Policy validation tests policies against historical authorization requests to identify potentially dangerous or overly permissive rules"], correct: 1, explanation: "When policy validation is enabled on a policy store, Verified Permissions validates Cedar policies against the schema before allowing them to be added. This validation checks that entity types, common types, and actions defined in the policy exist in the schema and are used correctly. Invalid policies that don't conform to the schema are rejected, preventing runtime errors and ensuring type safety in your authorization logic.", docLink: "https://docs.aws.amazon.com/verifiedpermissions/latest/userguide/policy-stores.html" },
            { id: 17, question: "What is deletion protection in Verified Permissions policy stores and how is it configured?", options: ["Deletion protection prevents unauthorized users from deleting policies; it requires MFA authentication for any delete operations", "Deletion protection prevents accidental deletion of a policy store; it's enabled by default for console-created stores but disabled for API/SDK-created stores", "Deletion protection creates automatic backups of policies to S3 before deletion; it's enabled globally across all regions by default", "Deletion protection locks policies for a specified retention period; it requires AWS Organizations Service Control Policies to override"], correct: 1, explanation: "Deletion protection prevents accidental deletion of a policy store. When enabled, the policy store cannot be deleted until protection is disabled. Deletion protection is automatically enabled on new policy stores created through the AWS Management Console, but is disabled by default for policy stores created through API or SDK calls. This asymmetric default behavior means API users must explicitly enable deletion protection if desired.", docLink: "https://docs.aws.amazon.com/verifiedpermissions/latest/userguide/policy-stores.html" },
            { id: 18, question: "What is the purpose of namespaces in Cedar policy stores for multi-tenant applications?", options: ["Namespaces partition network access controls by creating isolated VPC subnets for each tenant's authorization traffic", "Namespaces are string prefixes for entity types (e.g., TenantA::User) that prevent ambiguity and make tenant-specific policies easily identifiable in logs", "Namespaces allocate dedicated compute resources for policy evaluation to ensure tenant isolation and performance guarantees", "Namespaces define the DNS domain structure for routing authorization API calls to tenant-specific policy store endpoints"], correct: 1, explanation: "Namespaces are string prefixes for Cedar entity types separated by double colons (::), such as MyApp::User or TenantA::Document. Verified Permissions supports one namespace per policy store. In multi-tenant applications, namespaces help distinguish similar entities across tenants (TenantA::User vs TenantB::User), making authorization request logs more readable and preventing type collisions. They're recommended but optional for single-tenant applications.", docLink: "https://docs.aws.amazon.com/verifiedpermissions/latest/userguide/policy-stores.html" },
            { id: 19, question: "Which authorization API should applications use when they have an access token from an identity provider?", options: ["Applications should use the IsAuthorized API with manually extracted claims from the token passed as context attributes", "Applications should use the IsAuthorizedWithToken API, which accepts identity or access tokens and automatically extracts claims for policy evaluation", "Applications should use the BatchIsAuthorized API after decoding the JWT token and creating separate requests for each permission", "Applications should use the CreateAuthorizationRequest API after validating the token signature against the identity provider's public key"], correct: 1, explanation: "When applications have an identity or access token from an identity provider (like Cognito or OIDC), they should use the IsAuthorizedWithToken API. This API accepts the token directly, automatically extracts claims, and uses them in policy evaluation. This is simpler than manually parsing tokens and using IsAuthorized. The identity source configuration determines how token claims map to Cedar principal attributes for policy evaluation.", docLink: "https://docs.aws.amazon.com/verifiedpermissions/latest/userguide/cognito-create.html" },
            { id: 20, question: "What happens when client application ID validation is enabled for an Amazon Cognito identity source?", options: ["Verified Permissions validates that client IDs in the AWS account match those registered in the Cognito user pool configuration", "Verified Permissions validates that tokens contain one of the specified client IDs in the audience claim, rejecting tokens from unexpected applications", "Verified Permissions validates that client applications have the required IAM permissions to call the IsAuthorizedWithToken API", "Verified Permissions validates that client applications are using the latest SDK version and rejects requests from outdated clients"], correct: 1, explanation: "Client application ID validation ensures tokens are from expected client applications. When enabled, Verified Permissions checks that the token's audience claim (aud) contains one of the specified client IDs. Tokens from unexpected client applications are rejected. This prevents token theft scenarios where a token from one application is used to access another application sharing the same identity source. You can configure multiple valid client IDs for multi-client scenarios.", docLink: "https://docs.aws.amazon.com/verifiedpermissions/latest/userguide/cognito-create.html" },
            { id: 21, question: "What is the relationship between entities and groups/hierarchies in Cedar?", options: ["Entities are individual permission statements while groups are collections of policies bundled for management convenience", "Entities represent principals, actions, and resources; groups define parent-child relationships where child entities inherit attributes and membership from parents", "Entities are runtime authorization requests while groups are compile-time policy validation rules that check schema conformance", "Entities are stored in DynamoDB while groups are cached in ElastiCache for performance optimization during policy evaluation"], correct: 1, explanation: "In Cedar, entities represent principals, actions, and resources. Entities can be organized into groups/hierarchies where child entities can be members of parent entities. This enables role-based patterns - for example, a User entity can be a member of an Admin group entity. Cedar policies can reference parent entities, and authorization requests involving child entities will satisfy those policies due to the membership relationship. This supports both direct and transitive group membership.", docLink: "https://docs.cedarpolicy.com/overview/terminology.html#term-group" },
            { id: 22, question: "What is context data in Amazon Verified Permissions and how is it used in policy evaluation?", options: ["Context data includes the timestamp, source IP address, and user agent string automatically captured by Verified Permissions for audit logging", "Context data are attribute values providing additional information for policy evaluation, such as request metadata, environmental conditions, or application state", "Context data is the historical record of previous authorization decisions used by machine learning models to predict future access patterns", "Context data contains the schema definition and policy templates that must be loaded into memory before evaluation can begin"], correct: 1, explanation: "Context data are attribute values that provide additional information beyond the core principal, action, and resource for policy evaluation. Examples include: current time, source IP address, request metadata, environmental conditions, or application-specific state. Cedar policies can reference context attributes in when/unless conditions to implement dynamic, context-aware authorization. For instance, a policy might permit access only during business hours or from specific IP ranges.", docLink: "https://docs.aws.amazon.com/verifiedpermissions/latest/userguide/terminology.html" },
            { id: 23, question: "What is a policy template in Amazon Verified Permissions, and how does it differ from a static policy?", options: ["A policy template is an auto-generated policy created by analyzing CloudTrail logs to identify access patterns over time", "A policy template contains placeholder values for principals and/or resources that can be filled in to create multiple similar policies without duplication", "A policy template is a CloudFormation resource definition for deploying policy stores across multiple AWS accounts automatically", "A policy template is a machine-readable schema format that compiles into multiple Cedar policies for different environments"], correct: 1, explanation: "Policy templates are Cedar policies with placeholder values (represented as ?principal or ?resource) that can be instantiated multiple times with different actual values. This enables creating similar policies without duplication. For example, a template might define document access permissions with a ?resource placeholder, then be instantiated once per document. Templates improve maintainability - updating the template updates all linked policies. Static policies have no placeholders and are complete as written.", docLink: "https://docs.cedarpolicy.com/overview/terminology.html#policy-template" },
            { id: 24, question: "How does Amazon Verified Permissions integrate with Amazon API Gateway?", options: ["API Gateway automatically enforces all Verified Permissions policies without requiring custom code or Lambda authorizers", "When creating a policy store, you can import actions and resources from an API Gateway API to automatically populate the schema", "API Gateway replaces Verified Permissions as the authorization service when both are configured in the same application", "Verified Permissions stores API Gateway access logs for security analysis and anomaly detection using CloudWatch Insights"], correct: 1, explanation: "When creating a Verified Permissions policy store, you can optionally connect it to an Amazon API Gateway API. This integration automatically imports the API's resources and actions (operations) into your policy store schema. This creates an 'API-linked policy store' where entity types are derived from API Gateway configuration. A Lambda authorizer can then be deployed to enforce Verified Permissions authorization decisions for API requests.", docLink: "https://docs.aws.amazon.com/verifiedpermissions/latest/userguide/what-is-avp.html" },
            { id: 25, question: "Which AWS service is commonly used alongside Verified Permissions for authentication, and what is Verified Permissions' stance on authentication?", options: ["Verified Permissions requires AWS IAM Identity Center for authentication and cannot function without it being configured", "Verified Permissions is authentication-agnostic - it assumes authentication happened elsewhere via services like Cognito, OIDC, or IAM Identity Center and focuses solely on authorization", "Verified Permissions provides built-in authentication through its own user database and password management system separate from other AWS services", "Verified Permissions automatically synchronizes with AWS IAM policies to provide unified authentication and authorization across all AWS services"], correct: 1, explanation: "Amazon Verified Permissions is authentication-agnostic - it presumes the principal has been previously authenticated through other means such as Amazon Cognito, OIDC providers, IAM Identity Center, or custom authentication solutions. Verified Permissions focuses exclusively on authorization (determining what an authenticated principal can do), not authentication (verifying identity). This separation of concerns allows flexibility in choosing authentication mechanisms while maintaining centralized, consistent authorization logic.", docLink: "https://docs.aws.amazon.com/verifiedpermissions/latest/userguide/what-is-avp.html" }
        ];

        let currentMode = 'learn', currentQuestion = 0, userAnswers = [], answersRevealed = [], shuffledQuestions = [], timerInterval = null, timeRemaining = 0, inReviewMode = false, reviewedQuestions = [];
        function shuffleArray(a) { const b = [...a]; for (let i = b.length - 1; i > 0; i--) { const j = Math.floor(Math.random() * (i + 1)); [b[i], b[j]] = [b[j], b[i]]; } return b; }
        function shuffleQuestionOptions(q) { const idx = shuffleArray([0,1,2,3]); return { ...q, options: idx.map(i => q.options[i]), correct: idx.indexOf(q.correct) }; }
        function startQuiz(mode) { currentMode = mode; currentQuestion = 0; userAnswers = new Array(questions.length).fill(null); answersRevealed = new Array(questions.length).fill(false); shuffledQuestions = shuffleArray(questions).map(shuffleQuestionOptions); inReviewMode = false; reviewedQuestions = []; document.getElementById('modeSelector').classList.add('hidden'); document.getElementById('quizContent').classList.remove('hidden'); document.getElementById('resultsCard').classList.remove('show'); document.getElementById('totalQ').textContent = shuffledQuestions.length; document.getElementById('backToReviewBtn').style.display = 'none'; if (mode === 'exam') { timeRemaining = shuffledQuestions.length * 150; startTimer(); document.getElementById('shuffleBtn').classList.add('hidden'); } else { document.getElementById('timer').textContent = 'Learn Mode'; document.getElementById('shuffleBtn').classList.remove('hidden'); } renderQuestion(); }
        function startTimer() { updateTimerDisplay(); timerInterval = setInterval(() => { timeRemaining--; updateTimerDisplay(); if (timeRemaining <= 0) { clearInterval(timerInterval); showResults(); } }, 1000); }
        function updateTimerDisplay() { const m = Math.floor(timeRemaining / 60), s = timeRemaining % 60, el = document.getElementById('timer'); el.textContent = `${m}:${s.toString().padStart(2, '0')}`; el.classList.remove('warning', 'danger'); if (timeRemaining <= 60) el.classList.add('danger'); else if (timeRemaining <= 300) el.classList.add('warning'); }
        function renderQuestion() { const q = shuffledQuestions[currentQuestion], letters = ['A','B','C','D'], ans = userAnswers[currentQuestion], revealed = answersRevealed[currentQuestion]; let opts = q.options.map((o, i) => { let c = 'option'; if (currentMode === 'learn' && revealed) { c += ' disabled'; if (i === q.correct) c += ' correct'; else if (i === ans && ans !== q.correct) c += ' incorrect'; } else if (ans === i) c += ' selected'; return `<div class="${c}" onclick="selectOption(${i})"><span class="option-marker">${letters[i]}</span><span class="option-text">${o}</span></div>`; }).join(''); let exp = currentMode === 'learn' ? `<div class="explanation ${revealed ? 'show' : ''}"><div class="explanation-title">üìñ Explanation</div><div class="answer-header">Correct Answer: ${letters[q.correct]}</div><p class="explanation-text">${q.explanation}</p><a href="${q.docLink}" target="_blank" class="doc-link">üìÑ View AWS Documentation ‚Üí</a></div>` : ''; document.getElementById('questionsContainer').innerHTML = `<div class="question-card"><div class="question-header"><span class="question-number">Question ${currentQuestion + 1}</span><span class="question-domain">Verified Permissions</span></div><p class="question-text">${q.question}</p><div class="options">${opts}</div>${currentMode === 'learn' && !revealed ? '<button class="btn btn-primary" style="margin-top:1rem;width:100%;" onclick="revealAnswer()">Show Answer</button>' : ''}${exp}</div>`; document.getElementById('currentQ').textContent = currentQuestion + 1; document.getElementById('progressFill').style.width = `${((currentQuestion + 1) / shuffledQuestions.length) * 100}%`; document.getElementById('prevBtn').disabled = currentQuestion === 0; document.getElementById('nextBtn').textContent = currentQuestion === shuffledQuestions.length - 1 ? (currentMode === 'exam' ? 'Submit Quiz' : 'See Results') : 'Next ‚Üí'; }
        function selectOption(i) { if (currentMode === 'learn' && answersRevealed[currentQuestion]) return; userAnswers[currentQuestion] = i; renderQuestion(); }
        function revealAnswer() { if (userAnswers[currentQuestion] === null) userAnswers[currentQuestion] = -1; answersRevealed[currentQuestion] = true; renderQuestion(); }
        function navigate(d) { if (d === 1 && currentQuestion === shuffledQuestions.length - 1) { showResults(); return; } currentQuestion = Math.max(0, Math.min(currentQuestion + d, shuffledQuestions.length - 1)); renderQuestion(); }
        function shuffleQuiz() { if (currentMode !== 'learn') return; currentQuestion = 0; userAnswers = new Array(questions.length).fill(null); answersRevealed = new Array(questions.length).fill(false); shuffledQuestions = shuffleArray(questions).map(shuffleQuestionOptions); renderQuestion(); }
        function showResults() { if (timerInterval) clearInterval(timerInterval); let correct = shuffledQuestions.reduce((c, q, i) => c + (userAnswers[i] === q.correct ? 1 : 0), 0); const total = shuffledQuestions.length, pct = Math.round((correct / total) * 100), pass = pct >= 80; document.getElementById('quizContent').classList.add('hidden'); document.getElementById('resultsCard').classList.add('show'); document.getElementById('reviewSection').classList.remove('show'); document.getElementById('scorePercent').textContent = pct + '%'; document.getElementById('scorePercent').className = 'results-score ' + (pass ? 'pass' : 'fail'); document.getElementById('resultStatus').textContent = pass ? 'üéâ PASSED!' : 'üìö Keep Studying'; document.getElementById('resultStatus').className = 'results-status ' + (pass ? 'pass' : 'fail'); document.getElementById('resultDetails').textContent = `You answered ${correct} out of ${total} questions correctly.`; document.getElementById('correctCount').textContent = correct; document.getElementById('incorrectCount').textContent = total - correct; }
        function showReview() { const letters = ['A','B','C','D']; const tbody = document.getElementById('reviewTableBody'); tbody.innerHTML = shuffledQuestions.map((q, i) => { const userAns = userAnswers[i]; const isCorrect = userAns === q.correct; const userLetter = userAns !== null && userAns >= 0 ? letters[userAns] : 'No Answer'; const correctLetter = letters[q.correct]; const statusIcon = isCorrect ? '‚úì' : '‚úó'; const statusClass = isCorrect ? 'correct' : 'incorrect'; const qText = q.question.length > 120 ? q.question.substring(0, 120) + '...' : q.question; const reviewedClass = reviewedQuestions.includes(i) ? 'reviewed' : ''; return `<tr class="${reviewedClass}" onclick="reviewQuestion(${i})"><td class="review-q-num">${i + 1}</td><td class="review-q-text">${qText}</td><td class="review-answer ${userAns === q.correct ? 'correct' : 'incorrect'}">${userLetter}</td><td class="review-answer correct">${correctLetter}</td><td class="review-status ${statusClass}">${statusIcon}</td></tr>`; }).join(''); document.getElementById('resultsCard').classList.remove('show'); document.getElementById('reviewSection').classList.add('show'); inReviewMode = true; }
        function reviewQuestion(qIndex) { if (!reviewedQuestions.includes(qIndex)) { reviewedQuestions.push(qIndex); } currentMode = 'learn'; currentQuestion = qIndex; answersRevealed[qIndex] = true; document.getElementById('reviewSection').classList.remove('show'); document.getElementById('quizContent').classList.remove('hidden'); document.getElementById('timer').textContent = 'Learn Mode'; document.getElementById('shuffleBtn').style.display = 'none'; document.getElementById('backToReviewBtn').style.display = 'inline-block'; if (timerInterval) clearInterval(timerInterval); renderQuestion(); }
        function backToReview() { document.getElementById('quizContent').classList.add('hidden'); showReview(); }
        function backToResults() { document.getElementById('reviewSection').classList.remove('show'); document.getElementById('resultsCard').classList.add('show'); inReviewMode = false; }
        function restartQuiz() { document.getElementById('resultsCard').classList.remove('show'); document.getElementById('reviewSection').classList.remove('show'); document.getElementById('modeSelector').classList.remove('hidden'); document.getElementById('quizContent').classList.add('hidden'); document.getElementById('backToReviewBtn').style.display = 'none'; inReviewMode = false; reviewedQuestions = []; if (timerInterval) clearInterval(timerInterval); }
    </script>
</body>
</html>
