<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Amazon Security Lake Comprehensive Quiz | AWS Security Specialty (SCS-C03)</title>
    <style>
        :root {
            --bg-primary: #0a0e17;
            --bg-secondary: #141b2d;
            --bg-tertiary: #1a2236;
            --text-primary: #e2e8f0;
            --text-secondary: #94a3b8;
            --accent-primary: #06b6d4;
            --accent-secondary: #22d3ee;
            --success: #22c55e;
            --error: #ef4444;
            --warning: #eab308;
            --info: #3b82f6;
            --border: #2d3a52;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', system-ui, -apple-system, sans-serif;
            background: var(--bg-primary);
            color: var(--text-primary);
            line-height: 1.6;
            min-height: 100vh;
        }

        .container {
            max-width: 900px;
            margin: 0 auto;
            padding: 2rem;
        }

        header {
            text-align: center;
            margin-bottom: 2rem;
            padding: 2rem;
            background: linear-gradient(135deg, var(--bg-secondary) 0%, var(--bg-tertiary) 100%);
            border-radius: 16px;
            border: 1px solid var(--border);
        }

        .badge {
            display: inline-block;
            background: var(--accent-primary);
            color: white;
            padding: 0.25rem 0.75rem;
            border-radius: 20px;
            font-size: 0.75rem;
            font-weight: 600;
            margin-bottom: 1rem;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        h1 {
            font-size: 2rem;
            margin-bottom: 0.5rem;
            background: linear-gradient(135deg, var(--accent-primary), var(--accent-secondary));
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }

        .subtitle {
            color: var(--text-secondary);
            font-size: 1rem;
        }

        .stats-bar {
            display: flex;
            justify-content: center;
            gap: 2rem;
            margin-top: 1.5rem;
            padding-top: 1.5rem;
            border-top: 1px solid var(--border);
        }

        .stat {
            text-align: center;
        }

        .stat-value {
            font-size: 1.5rem;
            font-weight: 700;
            color: var(--accent-primary);
        }

        .stat-label {
            font-size: 0.75rem;
            color: var(--text-secondary);
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .mode-selector {
            display: flex;
            gap: 1rem;
            justify-content: center;
            margin-bottom: 2rem;
        }

        .mode-btn {
            flex: 1;
            max-width: 200px;
            padding: 1rem;
            background: var(--bg-secondary);
            border: 2px solid var(--border);
            border-radius: 12px;
            color: var(--text-primary);
            font-size: 1rem;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .mode-btn:hover {
            border-color: var(--accent-primary);
            transform: translateY(-2px);
        }

        .mode-btn.active {
            background: var(--accent-primary);
            border-color: var(--accent-primary);
            color: white;
        }

        .btn-container {
            display: flex;
            gap: 1rem;
            justify-content: center;
            margin-top: 2rem;
        }

        .btn {
            padding: 0.75rem 2rem;
            border: none;
            border-radius: 8px;
            font-size: 1rem;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .btn-primary {
            background: var(--accent-primary);
            color: white;
        }

        .btn-primary:hover {
            background: var(--accent-secondary);
            transform: translateY(-2px);
        }

        .btn-secondary {
            background: var(--bg-secondary);
            color: var(--text-primary);
            border: 2px solid var(--border);
        }

        .btn-secondary:hover {
            border-color: var(--accent-primary);
            transform: translateY(-2px);
        }

        .question-card {
            background: var(--bg-secondary);
            border-radius: 12px;
            padding: 2rem;
            margin-bottom: 2rem;
            border: 1px solid var(--border);
        }

        .question-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 1.5rem;
        }

        .question-number {
            font-size: 0.875rem;
            color: var(--text-secondary);
            font-weight: 600;
        }

        .question-text {
            font-size: 1.125rem;
            font-weight: 600;
            margin-bottom: 1.5rem;
            line-height: 1.6;
        }

        .options {
            display: flex;
            flex-direction: column;
            gap: 0.75rem;
        }

        .option {
            padding: 1rem;
            background: var(--bg-tertiary);
            border: 2px solid var(--border);
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .option:hover {
            border-color: var(--accent-primary);
            transform: translateX(4px);
        }

        .option.selected {
            border-color: var(--accent-primary);
            background: rgba(6, 182, 212, 0.1);
        }

        .option.correct {
            border-color: var(--success);
            background: rgba(34, 197, 94, 0.1);
        }

        .option.incorrect {
            border-color: var(--error);
            background: rgba(239, 68, 68, 0.1);
        }

        .option.disabled {
            cursor: not-allowed;
            opacity: 0.6;
        }

        .explanation {
            margin-top: 1.5rem;
            padding: 1rem;
            background: var(--bg-tertiary);
            border-left: 4px solid var(--info);
            border-radius: 8px;
            display: none;
        }

        .explanation.show {
            display: block;
        }

        .explanation-title {
            font-weight: 600;
            margin-bottom: 0.5rem;
            color: var(--info);
        }

        .doc-link {
            margin-top: 1rem;
            padding-top: 1rem;
            border-top: 1px solid var(--border);
        }

        .doc-link a {
            color: var(--accent-primary);
            text-decoration: none;
            font-size: 0.875rem;
        }

        .doc-link a:hover {
            text-decoration: underline;
        }

        .progress-bar {
            width: 100%;
            height: 8px;
            background: var(--bg-tertiary);
            border-radius: 4px;
            overflow: hidden;
            margin-bottom: 2rem;
        }

        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, var(--accent-primary), var(--accent-secondary));
            transition: width 0.3s ease;
        }

        .timer {
            text-align: center;
            font-size: 1.5rem;
            font-weight: 700;
            color: var(--accent-primary);
            margin-bottom: 2rem;
        }

        .results-card { background: var(--bg-secondary); border-radius: 16px; padding: 2rem; text-align: center; border: 1px solid var(--border); display: none; }
        .results-card.show { display: block; animation: fadeIn 0.5s ease; }
        .results-card h2 { font-size: 1.5rem; margin-bottom: 1rem; color: var(--text-secondary); }
        .results-score { font-size: 4rem; font-weight: 700; margin: 1rem 0; }
        .results-score.pass { color: var(--success); }
        .results-score.fail { color: var(--error); }
        .results-status { font-size: 1.5rem; margin-bottom: 1rem; }
        .results-status.pass { color: var(--success); }
        .results-status.fail { color: var(--error); }
        .results-details { color: var(--text-secondary); margin-bottom: 2rem; }
        .results-breakdown { display: flex; justify-content: center; gap: 3rem; margin-bottom: 2rem; padding: 1.5rem; background: var(--bg-tertiary); border-radius: 10px; }
        .breakdown-item { text-align: center; }
        .breakdown-value { font-size: 2rem; font-weight: 700; }
        .breakdown-value.correct { color: var(--success); }
        .breakdown-value.incorrect { color: var(--error); }
        .breakdown-label { font-size: 0.875rem; color: var(--text-secondary); }
        .hidden { display: none !important; }

        #startScreen, #quizScreen {
            display: none;
        }

        #startScreen.active, #quizScreen.active {
            display: block;
        }

        .review-section { background: var(--bg-secondary); border-radius: 16px; padding: 2rem; border: 1px solid var(--border); display: none; }
        .review-section.show { display: block; animation: fadeIn 0.5s ease; }
        .review-header { text-align: center; margin-bottom: 2rem; }
        .review-hint { text-align: center; color: var(--text-secondary); font-size: 0.875rem; margin-bottom: 1rem; }
        .review-table { width: 100%; border-collapse: collapse; margin-bottom: 2rem; }
        .review-table th { background: var(--bg-tertiary); color: var(--text-secondary); font-size: 0.875rem; font-weight: 600; text-transform: uppercase; padding: 1rem; text-align: left; border-bottom: 2px solid var(--border); }
        .review-table td { padding: 1rem; border-bottom: 1px solid var(--border); vertical-align: top; }
        .review-table tbody tr { cursor: pointer; transition: all 0.2s ease; }
        .review-table tbody tr:hover { background: rgba(6, 182, 212, 0.1); transform: translateX(4px); }
        .review-table tbody tr.reviewed { background: rgba(6, 182, 212, 0.25); border-left: 6px solid var(--accent-primary); box-shadow: inset 0 0 20px rgba(6, 182, 212, 0.15); }
        .review-table tbody tr.reviewed:hover { background: rgba(6, 182, 212, 0.3); }
        .review-table tbody tr.reviewed .review-q-num { color: var(--accent-secondary); font-weight: 800; }
        .review-table tbody tr.reviewed .review-q-num::before { content: "‚úì "; color: var(--accent-primary); font-size: 1rem; }
        .review-q-num { font-weight: 700; color: var(--accent-primary); white-space: nowrap; }
        .review-q-text { color: var(--text-primary); line-height: 1.6; }
        .review-answer { font-weight: 600; }
        .review-answer.correct { color: var(--success); }
        .review-answer.incorrect { color: var(--error); }
        .review-status { text-align: center; font-size: 1.25rem; }

        .btn-group {
            display: flex;
            gap: 1rem;
            justify-content: center;
            flex-wrap: wrap;
        }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <div class="badge">AWS Security Specialty (SCS-C03)</div>
            <h1>Amazon Security Lake</h1>
            <p class="subtitle">Comprehensive Quiz</p>
            <div class="stats-bar">
                <div class="stat">
                    <div class="stat-value">20</div>
                    <div class="stat-label">Questions</div>
                </div>
                <div class="stat">
                    <div class="stat-value">50</div>
                    <div class="stat-label">Minutes (Exam)</div>
                </div>
                <div class="stat">
                    <div class="stat-value">80%</div>
                    <div class="stat-label">Pass Threshold</div>
                </div>
            </div>
        </header>

        <div id="startScreen" class="active">
            <div class="mode-selector">
                <button class="mode-btn" onclick="startQuiz('learn')">üìö Learn Mode</button>
                <button class="mode-btn" onclick="startQuiz('exam')">‚è±Ô∏è Exam Mode</button>
            </div>
        </div>

        <div id="quizScreen">
            <div class="timer" id="timer" style="display: none;"></div>
            <div class="progress-bar">
                <div class="progress-fill" id="progressBar"></div>
            </div>
            <div id="questionContainer"></div>
            <button class="btn btn-secondary" id="backToReviewBtn" onclick="backToReview()" style="display: none;">‚Üê Back to Review</button>
            <div class="btn-container">
                <button class="btn btn-secondary" id="prevBtn">‚Üê Previous</button>
                <button class="btn btn-primary" id="nextBtn">Next ‚Üí</button>
                <button class="btn btn-primary" id="submitBtn" style="display: none;">Submit Quiz</button>
            </div>
        </div>

        <div class="results-card" id="resultsCard">
            <h2>Quiz Complete!</h2>
            <div class="results-score" id="scorePercent">0%</div>
            <div class="results-status" id="resultStatus">-</div>
            <p class="results-details" id="resultDetails"></p>
            <div class="results-breakdown">
                <div class="breakdown-item">
                    <div class="breakdown-value correct" id="correctCount">0</div>
                    <div class="breakdown-label">Correct</div>
                </div>
                <div class="breakdown-item">
                    <div class="breakdown-value incorrect" id="incorrectCount">0</div>
                    <div class="breakdown-label">Incorrect</div>
                </div>
            </div>
            <div class="btn-group" id="resultsButtons">
                <button class="btn btn-primary" id="reviewBtn" onclick="showReview()" style="display: none;">üìä Review Answers</button>
                <button class="btn btn-secondary" id="restartBtn" onclick="restartQuiz()">üîÑ Restart Quiz</button>
            </div>
        </div>

        <div class="review-section" id="reviewSection">
                <div class="review-header">
                    <h2>Answer Review</h2>
                    <p class="results-details">Click any question to review the full answer and explanation</p>
                </div>
                <p class="review-hint">üí° Tip: Click on any row to see the full question and explanation in Learn mode</p>
                <table class="review-table">
                    <thead>
                        <tr>
                            <th style="width: 5%">#</th>
                            <th style="width: 50%">Question</th>
                            <th style="width: 15%">Your Answer</th>
                            <th style="width: 15%">Correct Answer</th>
                            <th style="width: 10%">Status</th>
                        </tr>
                    </thead>
                    <tbody id="reviewTableBody"></tbody>
                </table>
                <div class="btn-group">
                    <button class="btn btn-secondary" onclick="backToResults()">‚Üê Back to Results</button>
                    <button class="btn btn-primary" onclick="restartQuiz()">üîÑ Restart Quiz</button>
                </div>
            </div>
        </div>
    </div>

    <script>
        let currentQuestion = 0;
        let score = 0;
        let mode = 'learn';
        let currentMode = 'learn';
        let userAnswers = [];
        let shuffledQuestions = [];
        let answersRevealed = [];
        let startTime;
        let timerInterval;
        let inReviewMode = false, reviewedQuestions = [];

        const questions = [
            {
                id: 1,
                question: "What is Amazon Security Lake?",
                options: [
                    "A threat detection service that identifies malicious activity across AWS accounts",
                    "A fully managed security data lake service that centralizes security data from multiple sources",
                    "A compliance service that validates security configurations against industry standards",
                    "A vulnerability management service that scans AWS resources for security weaknesses"
                ],
                correct: 1,
                explanation: "Amazon Security Lake is a fully managed security data lake service. It automatically centralizes security data from AWS environments, SaaS providers, on-premises, cloud sources, and third-party sources into a purpose-built data lake stored in your AWS account. The data lake is backed by Amazon S3 buckets, and you retain ownership over your data.",
                docLink: "https://docs.aws.amazon.com/security-lake/latest/userguide/what-is-security-lake.html"
            },
            {
                id: 2,
                question: "What storage service backs the Amazon Security Lake data lake?",
                options: [
                    "Amazon EBS volumes with encryption at rest",
                    "Amazon EFS file systems with lifecycle management",
                    "Amazon S3 buckets with customer ownership",
                    "Amazon Glacier Deep Archive for long-term storage"
                ],
                correct: 2,
                explanation: "The Security Lake data lake is backed by Amazon Simple Storage Service (Amazon S3) buckets. You retain ownership over your data, which provides you with full control over data access, lifecycle management, and integration with other AWS services.",
                docLink: "https://docs.aws.amazon.com/security-lake/latest/userguide/what-is-security-lake.html"
            },
            {
                id: 3,
                question: "What data format does Security Lake use to store ingested security data?",
                options: [
                    "JSON format with custom AWS security schema",
                    "CSV format with standardized security headers",
                    "Apache Parquet format with OCSF schema",
                    "Protocol Buffers with AWS-defined message types"
                ],
                correct: 2,
                explanation: "Security Lake converts ingested data into Apache Parquet format and a standard open-source schema called the Open Cybersecurity Schema Framework (OCSF). Parquet is a columnar storage format that's efficient for both storage and querying. OCSF normalizes and combines security data from AWS and enterprise security data sources.",
                docLink: "https://docs.aws.amazon.com/security-lake/latest/userguide/what-is-security-lake.html"
            },
            {
                id: 4,
                question: "What does OCSF stand for in the context of Amazon Security Lake?",
                options: [
                    "Open Cloud Security Framework",
                    "Operational Cybersecurity Standard Format",
                    "Open Cybersecurity Schema Framework",
                    "Optimized Cloud Storage Framework"
                ],
                correct: 2,
                explanation: "OCSF stands for Open Cybersecurity Schema Framework. It's a standard open-source schema that Security Lake uses to normalize and combine security data from AWS and a broad range of enterprise security data sources. This standardization makes the data compatible with other AWS services and third-party providers without the need for post-processing.",
                docLink: "https://docs.aws.amazon.com/security-lake/latest/userguide/what-is-security-lake.html"
            },
            {
                id: 5,
                question: "Which of the following is NOT a native AWS service from which Security Lake can collect log data?",
                options: [
                    "AWS CloudTrail management and data events",
                    "Amazon VPC Flow Logs",
                    "AWS WAFv2 Logs",
                    "Amazon CloudFront access logs"
                ],
                correct: 3,
                explanation: "Security Lake natively collects data from: AWS CloudTrail (management and data events for S3 and Lambda), Amazon EKS Audit Logs, Route 53 resolver query logs, AWS Security Hub CSPM findings, Amazon VPC Flow Logs, and AWS WAFv2 Logs. CloudFront access logs are not listed as a native source, though custom sources can be configured.",
                docLink: "https://docs.aws.amazon.com/security-lake/latest/userguide/internal-sources.html"
            },
            {
                id: 6,
                question: "What is a 'subscriber' in Amazon Security Lake?",
                options: [
                    "An IAM role that has permission to configure Security Lake settings",
                    "An AWS account that sends log data to the Security Lake data lake",
                    "A service or user that consumes data stored in Security Lake",
                    "An EventBridge rule that triggers on new security findings"
                ],
                correct: 2,
                explanation: "Subscribers consume data stored in Security Lake. You can control a subscriber's level of access to your data - they may consume data only from specific sources and AWS Regions that you specify. Subscribers can be automatically notified about new objects as they're written to the data lake or can query data from the data lake.",
                docLink: "https://docs.aws.amazon.com/security-lake/latest/userguide/subscriber-management.html"
            },
            {
                id: 7,
                question: "How does Security Lake notify subscribers about new data?",
                options: [
                    "Through AWS SNS topics with message filtering",
                    "Using Amazon EventBridge to send notifications when objects are written",
                    "Via AWS Lambda function invocations with S3 event data",
                    "Through CloudWatch Events with custom event patterns"
                ],
                correct: 1,
                explanation: "Security Lake uses Amazon EventBridge to notify subscribers when objects are written to the data lake. This event-driven approach allows subscribers to react to new security data in near real-time, enabling automated security workflows and timely analysis.",
                docLink: "https://docs.aws.amazon.com/security-lake/latest/userguide/subscriber-management.html"
            },
            {
                id: 8,
                question: "Which AWS service does Security Lake use to create and manage data catalog tables?",
                options: [
                    "Amazon Redshift Spectrum for external table definitions",
                    "AWS Glue for Data Catalog tables and crawlers",
                    "Amazon Athena for table schema definitions",
                    "AWS Lake Formation for table metadata only"
                ],
                correct: 1,
                explanation: "Security Lake uses AWS Glue crawlers to create AWS Glue Data Catalog tables and send newly written data to the Data Catalog. Security Lake also stores partition metadata for AWS Lake Formation tables in the Data Catalog. The Glue Data Catalog provides a unified metadata repository for all your data assets.",
                docLink: "https://docs.aws.amazon.com/security-lake/latest/userguide/what-is-security-lake.html"
            },
            {
                id: 9,
                question: "What is the role of AWS Lake Formation in Security Lake?",
                options: [
                    "Lake Formation encrypts all data at rest using customer-managed KMS keys",
                    "Lake Formation creates separate tables for each source that contributes data",
                    "Lake Formation manages S3 bucket lifecycle policies and data retention",
                    "Lake Formation performs ETL transformations on raw security log data"
                ],
                correct: 1,
                explanation: "Security Lake creates a separate AWS Lake Formation table for each source that contributes data to Security Lake. Lake Formation tables contain information about data from each source, including schema, partition, and data location information. Subscribers have the option to consume data by querying these Lake Formation tables.",
                docLink: "https://docs.aws.amazon.com/security-lake/latest/userguide/what-is-security-lake.html"
            },
            {
                id: 10,
                question: "Which AWS service does Security Lake use for event-driven processing and notification management?",
                options: [
                    "AWS Step Functions for workflow orchestration",
                    "Amazon SNS for pub/sub messaging",
                    "Amazon SQS for queue management and notifications",
                    "Amazon Kinesis Data Streams for real-time data processing"
                ],
                correct: 2,
                explanation: "Security Lake uses Amazon Simple Queue Service (Amazon SQS) to enable event-driven processing and manage notifications. SQS provides a reliable, scalable queue service that can buffer messages between different components of the Security Lake architecture.",
                docLink: "https://docs.aws.amazon.com/security-lake/latest/userguide/what-is-security-lake.html"
            },
            {
                id: 11,
                question: "Can Security Lake collect security data from on-premises environments?",
                options: [
                    "No, Security Lake only collects data from AWS services",
                    "Yes, through custom sources and third-party integrations",
                    "Only if the on-premises data is first sent to CloudWatch Logs",
                    "Yes, but only through AWS Direct Connect connections"
                ],
                correct: 1,
                explanation: "Yes, Security Lake can collect security data from on-premises environments, cloud sources, SaaS providers, and third-party sources in addition to AWS services. This multi-source capability allows you to centralize all your security data in one location for comprehensive security analysis.",
                docLink: "https://docs.aws.amazon.com/security-lake/latest/userguide/what-is-security-lake.html"
            },
            {
                id: 12,
                question: "What is a key benefit of Security Lake's multi-account and multi-Region data management capability?",
                options: [
                    "It automatically replicates all security findings to a central Security Hub account",
                    "It enables designation of rollup Regions to consolidate data and comply with data residency requirements",
                    "It creates cross-Region VPC peering connections for secure data transfer",
                    "It implements AWS Organizations SCPs to control data access across accounts"
                ],
                correct: 1,
                explanation: "You can centrally enable Security Lake across all Regions where it's available and across multiple AWS accounts. In Security Lake, you can designate rollup Regions to consolidate security log and event data from multiple Regions. This capability helps you comply with data residency compliance requirements by keeping data in specific geographic locations.",
                docLink: "https://docs.aws.amazon.com/security-lake/latest/userguide/multi-account-management.html"
            },
            {
                id: 13,
                question: "How does Security Lake handle data lifecycle management?",
                options: [
                    "By automatically deleting data after 90 days to reduce storage costs",
                    "With customizable retention settings and automated storage tiering",
                    "Through integration with AWS Backup for long-term archive",
                    "By requiring manual configuration of S3 lifecycle policies for each source"
                ],
                correct: 1,
                explanation: "Security Lake manages the lifecycle of your data with customizable retention settings and storage costs with automated storage tiering. It automatically partitions and converts incoming security data to Apache Parquet format, which is storage and query efficient. This automation reduces the operational burden of managing security data lifecycle.",
                docLink: "https://docs.aws.amazon.com/security-lake/latest/userguide/lifecycle-management.html"
            },
            {
                id: 14,
                question: "Which AWS service does Security Lake use to support ETL (extract, transform, load) jobs on raw data?",
                options: [
                    "AWS Glue jobs with Python or Scala scripts",
                    "AWS Lambda functions for serverless processing",
                    "Amazon EMR clusters with Spark transformations",
                    "AWS Data Pipeline with preconfigured activities"
                ],
                correct: 1,
                explanation: "Security Lake uses AWS Lambda functions to support extract, transform, and load (ETL) jobs on raw data. Lambda also registers partitions for source data in AWS Glue. This serverless approach provides a scalable and cost-effective way to process security data as it arrives.",
                docLink: "https://docs.aws.amazon.com/security-lake/latest/userguide/what-is-security-lake.html"
            },
            {
                id: 15,
                question: "Can subscribers query Security Lake data directly, or must they receive notifications?",
                options: [
                    "Subscribers can only receive notifications via EventBridge; querying is not supported",
                    "Subscribers must use AWS Glue jobs to extract data before querying",
                    "Subscribers can either be notified about new objects or query data from the data lake",
                    "All subscribers automatically have both notification and query access"
                ],
                correct: 2,
                explanation: "Subscribers have flexibility in how they consume data. They may be automatically notified about new objects as they're written to the data lake (push model), or subscribers can query data from the data lake (pull model). You control which access method each subscriber uses based on their needs and your security requirements.",
                docLink: "https://docs.aws.amazon.com/security-lake/latest/userguide/subscriber-management.html"
            },
            {
                id: 16,
                question: "What query services can you use to analyze data in Security Lake?",
                options: [
                    "Only Amazon Athena for ad-hoc SQL queries",
                    "Amazon Athena, Amazon Redshift, and third-party services that integrate with AWS Glue",
                    "AWS CloudTrail Insights and Amazon Detective exclusively",
                    "Amazon QuickSight with direct S3 access only"
                ],
                correct: 1,
                explanation: "You can consume the Amazon S3 objects in your security data lake by creating a subscriber that can read data in the OCSF schema. You can also query data using Amazon Athena, Amazon Redshift, and third-party subscription services that integrate with AWS Glue. This flexibility allows you to use the analysis tool that best fits your needs.",
                docLink: "https://docs.aws.amazon.com/security-lake/latest/userguide/subscriber-data-access.html"
            },
            {
                id: 17,
                question: "Does Security Lake automatically transform data from natively supported AWS services to OCSF format?",
                options: [
                    "No, you must configure AWS Glue jobs to perform the OCSF transformation",
                    "Yes, but only for CloudTrail and VPC Flow Logs",
                    "Yes, Security Lake automatically transforms data from natively supported AWS services to OCSF",
                    "No, OCSF transformation is only available for third-party data sources"
                ],
                correct: 2,
                explanation: "Yes, Security Lake automatically partitions incoming data from natively supported AWS services and converts it to Parquet format. It also transforms data from natively supported AWS services to the Open Cybersecurity Schema Framework (OCSF) open-source schema. This makes the data compatible with other AWS services and third-party providers without the need for post-processing.",
                docLink: "https://docs.aws.amazon.com/security-lake/latest/userguide/internal-sources.html"
            },
            {
                id: 18,
                question: "What is the primary benefit of Security Lake's data normalization using OCSF?",
                options: [
                    "It reduces storage costs by compressing data more efficiently",
                    "It enables multiple security solutions to consume data in parallel without post-processing",
                    "It automatically encrypts all data fields with AWS KMS",
                    "It improves query performance by creating optimized indexes"
                ],
                correct: 1,
                explanation: "Since Security Lake normalizes data to the OCSF standard, many security solutions can consume this data in parallel. The normalization makes the data compatible with other AWS services and third-party providers without the need for post-processing, significantly simplifying integration and analysis workflows.",
                docLink: "https://docs.aws.amazon.com/security-lake/latest/userguide/what-is-security-lake.html"
            },
            {
                id: 19,
                question: "How does Security Lake handle credentials between the service and subscribers?",
                options: [
                    "You must manually create and rotate IAM access keys for each subscriber",
                    "Security Lake automatically creates and exchanges the credentials needed",
                    "Subscribers use their AWS account root credentials to access the data",
                    "All subscribers share a single IAM role with cross-account access"
                ],
                correct: 1,
                explanation: "Security Lake automatically creates and exchanges the credentials needed between Security Lake and the subscriber. This automation reduces the operational burden and security risks associated with manual credential management, ensuring secure access to your security data.",
                docLink: "https://docs.aws.amazon.com/security-lake/latest/userguide/subscriber-management.html"
            },
            {
                id: 20,
                question: "Which of the following best describes Security Lake's approach to data collection?",
                options: [
                    "Manual configuration required for each data source with custom Lambda functions",
                    "Automatic collection from integrated AWS services with customizable source selection",
                    "Real-time streaming only, with no support for batch data ingestion",
                    "Requires third-party SIEM tools to aggregate data before Security Lake ingestion"
                ],
                correct: 1,
                explanation: "Security Lake automates the collection of security-related log and event data from integrated AWS services and third-party services. While collection is automatic, you retain control and can specify which sources, accounts, and Regions you want to configure for log collection, making it both automated and customizable.",
                docLink: "https://docs.aws.amazon.com/security-lake/latest/userguide/source-management.html"
            }
        ];

        // Initialize
        document.getElementById('prevBtn').addEventListener('click', previousQuestion);
        document.getElementById('nextBtn').addEventListener('click', nextQuestion);
        document.getElementById('submitBtn').addEventListener('click', submitQuiz);
        document.getElementById('restartBtn').addEventListener('click', restartQuiz);
        document.getElementById('reviewBtn').addEventListener('click', showReview);

        function startQuiz(selectedMode) {
            mode = selectedMode;
            currentMode = selectedMode;
            currentQuestion = 0;
            score = 0;
            userAnswers = new Array(questions.length).fill(null);
            answersRevealed = new Array(questions.length).fill(false);
            shuffledQuestions = shuffleArray(questions).map(q => shuffleQuestionOptions(q));
            startTime = Date.now();
            inReviewMode = false;
            reviewedQuestions = [];

            document.getElementById('startScreen').classList.remove('active');
            document.getElementById('quizScreen').classList.add('active');
            document.getElementById('reviewSection').classList.remove('show');
            document.getElementById('backToReviewBtn').style.display = 'none';

            if (mode === 'exam') {
                startTimer();
                document.getElementById('timer').style.display = 'block';
            }

            showQuestion();
        }

        function startTimer() {
            const duration = 50 * 60; // 50 minutes in seconds
            let timeLeft = duration;

            timerInterval = setInterval(() => {
                timeLeft--;
                const minutes = Math.floor(timeLeft / 60);
                const seconds = timeLeft % 60;
                document.getElementById('timer').textContent = 
                    `Time Remaining: ${minutes}:${seconds.toString().padStart(2, '0')}`;

                if (timeLeft <= 0) {
                    clearInterval(timerInterval);
                    submitQuiz();
                }
            }, 1000);
        }

        function showQuestion() {
            const question = shuffledQuestions[currentQuestion];
            const container = document.getElementById('questionContainer');
            
            const isAnswered = userAnswers[currentQuestion] !== null;
            const showExplanation = mode === 'learn' && isAnswered;

            container.innerHTML = `
                <div class="question-card">
                    <div class="question-header">
                        <span class="question-number">Question ${currentQuestion + 1} of ${shuffledQuestions.length}</span>
                    </div>
                    <div class="question-text">${question.question}</div>
                    <div class="options">
                        ${question.options.map((option, index) => `
                            <div class="option ${userAnswers[currentQuestion] === index ? 'selected' : ''} 
                                ${showExplanation ? (index === question.correct ? 'correct' : userAnswers[currentQuestion] === index ? 'incorrect' : '') : ''}"
                                onclick="selectAnswer(${index})" 
                                ${(mode === 'learn' && isAnswered) || inReviewMode ? 'style="pointer-events: none;"' : ''}>
                                ${String.fromCharCode(65 + index)}. ${option}
                            </div>
                        `).join('')}
                    </div>
                    ${showExplanation || inReviewMode ? `
                        <div class="explanation show">
                            <div class="explanation-title">
                                ${userAnswers[currentQuestion] === question.correct ? '‚úì Correct!' : '‚úó Incorrect'}
                            </div>
                            <p>${question.explanation}</p>
                            <div class="doc-link">
                                <a href="${question.docLink}" target="_blank">üìö View AWS Documentation ‚Üí</a>
                            </div>
                        </div>
                    ` : ''}
                </div>
            `;

            updateProgress();
            updateNavigation();
        }

        function selectAnswer(index) {
            if (mode === 'learn' && userAnswers[currentQuestion] !== null) return;
            if (mode === 'exam' && inReviewMode) return;

            userAnswers[currentQuestion] = index;
            showQuestion();
        }

        function nextQuestion() {
            if (currentQuestion < shuffledQuestions.length - 1) {
                currentQuestion++;
                showQuestion();
            }
        }

        function previousQuestion() {
            if (currentQuestion > 0) {
                currentQuestion--;
                showQuestion();
            }
        }

        function updateProgress() {
            const progress = ((currentQuestion + 1) / shuffledQuestions.length) * 100;
            document.getElementById('progressBar').style.width = progress + '%';
        }

        function updateNavigation() {
            const prevBtn = document.getElementById('prevBtn');
            const nextBtn = document.getElementById('nextBtn');
            const submitBtn = document.getElementById('submitBtn');

            prevBtn.style.display = currentQuestion === 0 ? 'none' : 'inline-block';

            if (mode === 'exam') {
                const allAnswered = userAnswers.every(a => a !== null);
                nextBtn.style.display = currentQuestion === shuffledQuestions.length - 1 ? 'none' : 'inline-block';
                submitBtn.style.display = allAnswered ? 'inline-block' : 'none';
            } else {
                nextBtn.style.display = currentQuestion === shuffledQuestions.length - 1 ? 'none' : 'inline-block';
                submitBtn.style.display = 'none';
            }
        }

        function submitQuiz() {
            if (timerInterval) clearInterval(timerInterval);

            let correct = 0;
            userAnswers.forEach((ans, idx) => {
                if (ans !== null && ans !== -1 && ans === shuffledQuestions[idx].correct) correct++;
            });

            const total = shuffledQuestions.length;
            const percentage = Math.round((correct / total) * 100);
            const passed = percentage >= 80;

            document.getElementById('quizScreen').classList.remove('active');
            document.getElementById('resultsCard').classList.add('show');

            document.getElementById('scorePercent').textContent = `${percentage}%`;
            document.getElementById('scorePercent').className = `results-score ${passed ? 'pass' : 'fail'}`;
            document.getElementById('resultStatus').textContent = passed ? 'üéâ Congratulations! You passed!' : 'üìö Keep Studying';
            document.getElementById('resultStatus').className = `results-status ${passed ? 'pass' : 'fail'}`;
            document.getElementById('resultDetails').textContent = `You answered ${correct} out of ${total} questions correctly.`;
            document.getElementById('correctCount').textContent = correct;
            document.getElementById('incorrectCount').textContent = total - correct;
            document.getElementById('reviewSection').classList.remove('show');
            document.getElementById('reviewBtn').style.display = currentMode === 'exam' ? 'inline-block' : 'none';
        }

        function showReview() {
            const letters = ['A','B','C','D'];
            const tbody = document.getElementById('reviewTableBody');
            tbody.innerHTML = shuffledQuestions.map((q, i) => {
                const userAns = userAnswers[i];
                const isCorrect = userAns === q.correct;
                const userLetter = userAns !== null && userAns >= 0 ? letters[userAns] : 'No Answer';
                const correctLetter = letters[q.correct];
                const statusIcon = isCorrect ? '‚úì' : '‚úó';
                const statusClass = isCorrect ? 'correct' : 'incorrect';
                const qText = q.question.length > 120 ? q.question.substring(0, 120) + '...' : q.question;
                const reviewedClass = reviewedQuestions.includes(i) ? 'reviewed' : '';
                return `<tr class="${reviewedClass}" onclick="reviewQuestion(${i})"><td class="review-q-num">${i + 1}</td><td class="review-q-text">${qText}</td><td class="review-answer ${userAns === q.correct ? 'correct' : 'incorrect'}">${userLetter}</td><td class="review-answer correct">${correctLetter}</td><td class="review-status ${statusClass}">${statusIcon}</td></tr>`;
            }).join('');
            document.getElementById('resultsCard').classList.remove('show');
            document.getElementById('reviewSection').classList.add('show');
            inReviewMode = true;
        }

        function reviewQuestion(qIndex) {
            if (!reviewedQuestions.includes(qIndex)) {
                reviewedQuestions.push(qIndex);
            }
            currentMode = 'learn';
            currentQuestion = qIndex;
            answersRevealed[qIndex] = true;
            document.getElementById('reviewSection').classList.remove('show');
            document.getElementById('quizScreen').classList.add('active');
            document.getElementById('backToReviewBtn').style.display = 'inline-block';
            document.getElementById('prevBtn').style.display = 'none';
            document.getElementById('nextBtn').style.display = 'none';
            document.getElementById('submitBtn').style.display = 'none';
            if (timerInterval) clearInterval(timerInterval);
            showQuestion();
        }

        function backToReview() {
            document.getElementById('quizScreen').classList.remove('active');
            showReview();
        }

        function backToResults() {
            document.getElementById('reviewSection').classList.remove('show');
            document.getElementById('resultsCard').classList.add('show');
            inReviewMode = false;
        }

        function restartQuiz() {
            if (timerInterval) clearInterval(timerInterval);
            document.getElementById('resultsCard').classList.remove('show');
            document.getElementById('startScreen').classList.add('active');
            document.getElementById('timer').style.display = 'none';
            document.getElementById('reviewSection').classList.remove('show');
            document.getElementById('backToReviewBtn').style.display = 'none';
            inReviewMode = false;
            reviewedQuestions = [];
        }

        function shuffleArray(array) {
            const newArray = [...array];
            for (let i = newArray.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [newArray[i], newArray[j]] = [newArray[j], newArray[i]];
            }
            return newArray;
        }

        function shuffleQuestionOptions(question) {
            const indices = shuffleArray([0, 1, 2, 3]);
            return {
                ...question,
                options: indices.map(i => question.options[i]),
                correct: indices.indexOf(question.correct)
            };
        }
    </script>
</body>
</html>
